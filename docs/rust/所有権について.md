# 所有権について

- ヒープ領域にメモリ領域を確保したり、それを解放する機能を言語側で管理するための概念
    - ヒープ領域: 動的に確保と解放を繰り返せるメモリ領域のこと
- 多くの言語では、メモリの確保と解放を行うための仕組みとして、ガベージコレクションを採用している
- ガベージコレクション（garbage collection、GC）: コンピュータプログラムが動的に確保したメモリ領域のうち、不要になった領域を自動的に解放する機能のこと
- ガベージコレクションを採用している言語では、ガベージコレクタがメモリの確保と解放を行うための機能を言語側で管理するため、プログラマがメモリの確保と解放を意識する必要がない
- ガベージコレクタは実行時のオーバーヘッドがかかりプログラムの実行速度を低下させてしまうというデメリットがある
    - ガベージコレクションを取り入れている言語
        - Go, Java, Python, Ruby, JavaScript
- Rustでは所有権という概念を取り入れることでメモリの確保と解放をうまく取り扱えるようにした。

## Rustの所有権の挙動について

前提として、Rustには以下のような概念が存在する

- 各値は「所有者」と呼ばれる変数によって管理される
- 各変数が値に対して所有権を持っている

## 一度に存在できる値は1つだけ

以下のサンプルコードでは、変数s1から変数s2に所有権の移動が発生しているため、変数s1を利用するとコンパイルエラーが発生する

```rust
 fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // 変数s1から変数s2に所有権の移動が発生（一度に存在できる所有者は1人だけ）

    // 所有権が移動しているので、変数s1を利用するとコンパイルエラーが起きる
    // println!("{}, world!", s1); // value borrowed here after move

    println!("{}, world!", s2);
}
```

## 所有権を持つ変数がスコープを抜けると、その変数が指し示すメモリ領域は解放される

```rust
fn main() {
    let s1 = String::from("hello");

    {
        let s2 = String::from("hi");
        println!("{}, world!", s2);
    } // 値"hi"の所有者であるs2がスコープが外れるので、"hi"は破棄される

    println!("{}, world!", s1);
}  // 値"hello"の所有者であるs1がスコープが外れるので、"hello"は破棄される
```

## 参考

https://ai-techblog.hatenablog.com/entry/2023/03/27/084330#Rust%E3%81%AE%E6%89%80%E6%9C%89%E6%A8%A9%E3%81%A8%E3%81%AF
